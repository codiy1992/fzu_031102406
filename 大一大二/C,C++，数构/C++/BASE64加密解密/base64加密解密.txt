　方法一：　/// <summary> 　　/// Base64加密 　　/// </summary> 　　/// <param name="Message"></param> 　　/// <returns></returns> 　　public string Base64Code(string Message) 　　{ 　　char[] Base64Code = new char[]{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T', 　　'U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n', 　　'o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7', 　　'8','9','+','/','='}; 　　byte empty = (byte)0; 　　System.Collections.ArrayList byteMessage = new System.Collections.ArrayList(System.Text.Encoding.Default.GetBytes(Message)); 　　System.Text.StringBuilder outmessage; 　　int messageLen = byteMessage.Count; 　　//将字符分成3个字节一组，如果不足，则以0补齐 　　int page = messageLen / 3; 　　int use = 0; 　　if ((use = messageLen % 3) > 0) 　　{ 　　for (int i = 0; i < 3 - use; i++) 　　byteMessage.Add(empty); 　　page++; 　　} 　　//将3个字节的每组字符转换成4个字节一组的。3个一组，一组一组变成4个字节一组 　　//方法是：转换成ASCII码，按顺序排列24 位数据，再把这24位数据分成4组，即每组6位。再在每组的的最高位前补两个0凑足一个字节。 　　outmessage = new System.Text.StringBuilder(page * 4); 　　for (int i = 0; i < page; i++) 　　{ 　　//取一组3个字节的组 　　byte[] instr = new byte[3]; 　　instr[0] = (byte)byteMessage[i * 3]; 　　instr[1] = (byte)byteMessage[i * 3 + 1]; 　　instr[2] = (byte)byteMessage[i * 3 + 2]; 　　//六个位为一组，补0变成4个字节 　　int[] outstr = new int[4]; 　　//第一个输出字节：取第一输入字节的前6位，并且在高位补0，使其变成8位（一个字节） 　　outstr[0] = instr[0] >> 2; 　　//第二个输出字节：取第一输入字节的后2位和第二个输入字节的前4位（共6位），并且在高位补0，使其变成8位（一个字节） 　　outstr[1] = ((instr[0] & 0x03) << 4) ^ (instr[1] >> 4); 　　//第三个输出字节：取第二输入字节的后4位和第三个输入字节的前2位（共6位），并且在高位补0，使其变成8位（一个字节） 　　if (!instr[1].Equals(empty)) 　　outstr[2] = ((instr[1] & 0x0f) << 2) ^ (instr[2] >> 6); 　　else 　　outstr[2] = 64; 　　//第四个输出字节：取第三输入字节的后6位，并且在高位补0，使其变成8位（一个字节） 　　if (!instr[2].Equals(empty)) 　　outstr[3] = (instr[2] & 0x3f); 　　else 　　outstr[3] = 64; 　　outmessage.Append(Base64Code[outstr[0]]); 　　outmessage.Append(Base64Code[outstr[1]]); 　　outmessage.Append(Base64Code[outstr[2]]); 　　outmessage.Append(Base64Code[outstr[3]]); 　　} 　　return outmessage.ToString(); 　　} 　　/// <summary> 　　/// Base64解密 　　/// </summary> 　　/// <param name="Message"></param> 　　/// <returns></returns> 　　public string Base64Decode(string Message) 　　{ 　　if ((Message.Length % 4) != 0) 　　{ 　　throw new ArgumentException("不是正确的BASE64编码，请检查。", "Message"); 　　} 　　if (!System.Text.RegularExpressions.Regex.IsMatch(Message, "^[A-Z0-9/+=]*$", System.Text.RegularExpressions.RegexOptions.IgnoreCase)) 　　{ 　　throw new ArgumentException("包含不正确的BASE64编码，请检查。", "Message"); 　　} 　　string Base64Code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; 　　int page = Message.Length / 4; 　　System.Collections.ArrayList outMessage = new System.Collections.ArrayList(page * 3); 　　char[] message = Message.ToCharArray(); 　　for (int i = 0; i < page; i++) 　　{ 　　byte[] instr = new byte[4]; 　　instr[0] = (byte)Base64Code.IndexOf(message[i * 4]); 　　instr[1] = (byte)Base64Code.IndexOf(message[i * 4 + 1]); 　　instr[2] = (byte)Base64Code.IndexOf(message[i * 4 + 2]); 　　instr[3] = (byte)Base64Code.IndexOf(message[i * 4 + 3]); 　　byte[] outstr = new byte[3]; 　　outstr[0] = (byte)((instr[0] << 2) ^ ((instr[1] & 0x30) >> 4)); 　　if (instr[2] != 64) 　　{ 　　outstr[1] = (byte)((instr[1] << 4) ^ ((instr[2] & 0x3c) >> 2)); 　　} 　　else 　　{ 　　outstr[2] = 0; 　　} 　　if (instr[3] != 64) 　　{ 　　outstr[2] = (byte)((instr[2] << 6) ^ instr[3]); 　　} 　　else 　　{ 　　outstr[2] = 0; 　　} 　　outMessage.Add(outstr[0]); 　　if (outstr[1] != 0) 　　outMessage.Add(outstr[1]); 　　if (outstr[2] != 0) 　　outMessage.Add(outstr[2]); 　　} 　　byte[] outbyte = (byte[])outMessage.ToArray(Type.GetType("System.Byte")); 　　return System.Text.Encoding.Default.GetString(outbyte); 　　}
直接使用.NET中的的库类函数
　　方法二： 　　/// <summary> 　　/// Base64加密 　　/// </summary> 　　/// <param name="Message"></param> 　　/// <returns></returns> 　　public string Base64Code(string Message) 　　{ 　　byte[] bytes = Encoding.Default.GetBytes(Message); 　　return Convert.ToBase64String(bytes); 　　} 　　/// <summary> 　　/// Base64解密 　　/// </summary> 　　/// <param name="Message"></param> 　　/// <returns></returns> 　　public string Base64Decode(string Message) 　　{ 　　byte[] bytes = Convert.FromBase64String(Message); 　　return Encoding.Default.GetString(bytes); 　　}
编辑本段Base64-MIME
　　在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。 　　完整的base64定义可见 RFC1421和 RFC2045。编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC822规定，每76个字符，还需要加上一个回车换行。可以估算编码后数据长度大约为原长的135.1%。 　　转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的Bit用0补足。然后，每次取出6个bit，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。 　　如果最后剩下两个输入数据，在编码结果后加1个“=”；如果最后剩下一个输入数据，编码结果后加2个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。 　　举例来说，一段引用自Thomas Hobbes's Leviathan的文句： 　　Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure. 　　经过base64编码之后变成： 　　TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz 　　IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg 　　dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu 　　dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo 　　ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=